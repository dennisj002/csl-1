5
// nb. some of the testing code is attempting to see if it can cause an error it is not necessarily meant to be exemplary 
verbosity 1 = 
Root     
: sp ; //stack pause ; sp
Int User Combinators
{ "_TestDone_" _defined not } { "_TestDone_" _var } if 
sp
: iinc "./init.csl" include ;
: interpT "namespaces/compiler/interpreter.csl" include ;
: itest _TestDone_ @ { "namespaces/test/initTest.csl" include } if1 ;
: classTest "namespaces/test/classTest.csl" include ;
: arrayTest "namespaces/test/arrayTest.csl" include ;
: localsTest "namespaces/test/localsTest.csl" include ;
: bigNumTest "namespaces/test/bigNum.csl" include ;
: stackTest "namespaces/test/stack.csl" include ;
: controlTest "namespaces/test/control.csl" include ;
: objectTest "namespaces/test/dobject.csl" include ;
: c_SyntaxTest "namespaces/compiler/c_syntax.csl" include ;
: syntaxTest "namespaces/compiler/syntax.csl" include ;
: preprocessorTest "namespaces/compiler/preprocessor.csl" include ;
: test "namespaces/test/test.csl" include ;
: dT0 "namespaces/test/dev0.csl" include ;
: dT2 "namespaces/test/dev2.csl" include ;
: dT3 "namespaces/test/dev3.csl" include ;
: loT "namespaces/test/logic.csl" include ;
: dT "namespaces/test/dev.csl" include ; inline
: dT2 "namespaces/test/dev2.csl" include ;
: mT "namespaces/test/math.csl" include ;
: fT "namespaces/test/file.csl" include ;
: sT "namespaces/compiler/syntax.csl" include ;
: sysT "namespaces/test/system.csl" include ;
: lispTest "namespaces/test/lisp.csl" include ;
: oldL "namespaces/test/oldLisp.csl" include ;
: stT stackTest ;
: bT bigNumTest ;
: locT localsTest ;
: aT arrayTest ;
: cT classTest ;
: cntT controlTest ;
: oT objectTest ;
: cST c_SyntaxTest ;
: ppT preprocessorTest ;
: lT lispTest ;
C
: sp ; //stack pause ; sp
#if 1 //doX64
: basicT bT ppT cT mT aT loT locT fT oT cntT lT sT sysT interpT stT cST dT0 x64 ; //x64 ;
//: basicT bT ppT cT mT aT loT locT fT oT cntT lT sT sysT interpT stT cST x64 ; //x64 ;
#elif 1 //doTX64
: basicT bT ppT cT mT aT loT locT fT oT cntT lT sT sysT interpT stT dT0 x64 ; //cST dT0 x64 ; //x64 ;
#else
: basicT ppT cT mT aT loT bT locT fT oT cntT lT sT sysT interpT stT cST dT0 ;
//: basicT ppT cT mT aT loT bT locT fT oT     cntT lT sT sysT dT0 ; //interpT stT cST dT0 ;
#endif
: _basicT bT mT cntT lT fT sysT  ;
: testBasic basicT ;
// : testAll testBasic testX ;
: testAll cT aT loT bT locT mT oT x64 cntT lT fT sT cST ;
: testIt testAll ;
: dtestAll cT aT lT loT mT oT x64 cntT ; // for stepping thru test
: demo! sOn 5 itest ;
: odemo sOff 5 itest ;
: demo 1 ti _TestDone_ @ not { itest } if1 dT rtw 1 time ; //dT0 ; 
: tdemo ( n ) { n @ } { demo n -- } while ; 
//' demo wdiss pause
// : demo dT ;
: test0 x64 dT ; inline
: test1 inlineOff optimizeOff test0 ;
: aoTest odemo cntT ;
: aTest demo cntT ;
: tL lT dT0 ;
: tL2 dT0 lT ;
: tcd tc demo ;

// the action starts here
nl "before testAll" prints
 
"doTest" 1 const
System Combinators
: sp ; // stack pause ; 
sp 

#if 0 
: itt { doTest _TestDone_ @ not && } { basicT testX _TestDone_ ++ } if2 ; 
' itt wdiss itt //pause
#elif 0
"\ntest nested elif 0 - wrong\n" ps pause
#elif 0
"\ntest nested elif 0 - wrong\n" ps pause
#elif 1
#if 0 // if 1
"\ntest nested if 0 - wrong \n" ps pause
#elif 0 
"\ntest nested elif 1 - wrong \n" ps pause
sp
{ doTest _TestDone_ @ not && } { basicT _TestDone_ ++ } if2  
#elif 0
"\ntest nested elif 1 - wrong \n" ps pause
: shellOff "Shell" notUsing ;
Shell
doTest _TestDone_ @ not && 
if
    basicT _TestDone_ ++  
//else 
endif
shellOff
stack pause
#elif 1    
"\ntest nested elif 1 - correct \n" ps //pause
: shellOff "Shell" notUsing ;
Shell
if ( doTest _TestDone_ @ not && )
    basicT _TestDone_ ++  
//else 
endif
shellOff
//stack //pause
#endif // end if 1
#endif // end if 0
Interpreter
nl "_TestDone_ =" ps _TestDone_ @ p nl
//stack pause
//mem pause
{ _TestDone_ @ not } { pause } if2 
//stack pause
2 + 7 assertStkChk // stack checking


