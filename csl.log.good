
Stack : word at ./namespaces/compiler/lcinit.csl : 62.3 :> d: <: 1 cell pushed. TOS set to 0x0000000000000005.
Debug Menu at : 
./namespaces/compiler/lcinit.csl : 62.4 :
(m)enu, so(U)rce, dum(p), (e)val, (d)is, dis(a)ccum, dis(A)ccum, (r)egisters, (l)ocals, (v)ariables, (I)nfo, (W)dis, s(h)ow
(R)eturnStack, sto(P), (S)tate, (c)ontinue, (s)tep, (o)ver, (i)nto, o(u)t, t(h)ru, s(t)ack, auto(z), (V)erbosity, (q)uit, a(B)ort
usi(N)g, s(H)ow DebugWordList, sh(O)w CompilerWordList, Goto(L)ist_Print, T(y)peStackPrint, (w)diss, e(x)it
'\n' - escape, , '\' - <esc> - escape, ' ' - <space> - continue
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.4 : Lisp :> ( <: cprimitive :> d: (count-change 100)e
_LO_Eval : l0 =  ( count-change 100 )
_LO_Eval : l0 =  count-change
_LO_EvalSymbol : count-change
_LO_Eval : l1 =  count-change
LO_EvalList : lfunction =  count-change 100
_LO_Eval : l0 =  100
_LO_Eval : l1 =  100
_LO_EvalList : lnode : =  100
_LO_EvalList : le : = 100 le->Name = 100
_LO_EvalList : LO_CopyOne : le1 :  100
LO_Apply : lfunction with args ::  count-change ( 100 )
LO_Substitute : lambdaParameters =  ( amount )
LO_Substitute : funcCallValues =  ( 100 )
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  100
_LO_Eval : l0 =  cc
_LO_EvalSymbol : cc
_LO_Eval : l1 =  cc
LO_EvalList : lfunction =  cc amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 100
_LO_Eval : l1 =  100
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 100 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  100
_LO_Eval : l0 =  5
_LO_Eval : l1 =  5
_LO_EvalList : lnode : =  5
_LO_EvalList : le : = 5 le->Name = 5
_LO_EvalList : LO_CopyOne : le1 :  5
LO_Apply : lfunction with args ::  cc ( 100 5 )
LO_Substitute : lambdaParameters =  ( kinds-of-coins amount )
LO_Substitute : funcCallValues =  ( 100 5 )
LO_Substitute : lambdaParameters =  kinds-of-coins
LO_Substitute : funcCallValues =  100
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  5
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  5
LO_EvalList : special function =  ( cond ( ( <= amount 0 ) 1 ) ( ( or ( < amount 0 ) ( = kinds-of-coins 0 ) ) 0 ) ( else ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) ) ) )
LO_Cond : l0 =  cond
LO_Cond : conditional =  ( ( <= amount 0 ) 1 )
LO_Cond : testNode =  ( <= amount 0 )
_LO_Eval : l0 =  ( <= amount 0 )
_LO_Eval : l0 =  <=
_LO_EvalSymbol : <=
_LO_Eval : l1 =  <=
LO_EvalList : lfunction =  <= amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 5
_LO_Eval : l1 =  5
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 5 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  5
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  <= ( 5 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 5 <: 0x00007ffff77bb3b0 :> z
Debugger :: Starting AutoMode : automatically repeating key :: 'e' ...
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 5 <: 0x00007ffff77bb3b0 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 5 <: 1 cell pushed. TOS set to 0x0000000000000005.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77bd838 :> d: (count-change 100)
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> <= <: cprimitive :>  .. e (cc amount kinds-of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coi .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> <= <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  <= ( 5 0 ) 0
LO_EvalList : lfunction =  <= ( 5 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
LO_Cond : testTorF =  0
LO_Cond : conditional =  ( ( or ( < amount 0 ) ( = kinds-of-coins 0 ) ) 0 )
LO_Cond : testNode =  ( or ( < amount 0 ) ( = kinds-of-coins 0 ) )
_LO_Eval : l0 =  ( or ( < amount 0 ) ( = kinds-of-coins 0 ) )
_LO_Eval : l0 =  or
_LO_EvalSymbol : or
_LO_Eval : l1 =  or
LO_EvalList : lfunction =  or ( < amount 0 )
_LO_Eval : l0 =  ( < amount 0 )
_LO_Eval : l0 =  <
_LO_EvalSymbol : <
_LO_Eval : l1 =  <
LO_EvalList : lfunction =  < amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 5
_LO_Eval : l1 =  5
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 5 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  5
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  < ( 5 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 5 <: 0x00007ffff77bb3b0 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 5 <: 1 cell pushed. TOS set to 0x0000000000000005.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77be5f8 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> < <: cprimitive :>  .. coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ (cc  .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> < <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  < ( 5 0 ) 0
LO_EvalList : lfunction =  < ( 5 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  ( < amount 0 )
_LO_EvalList : le : = 0 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  0
_LO_Eval : l0 =  ( = kinds-of-coins 0 )
_LO_Eval : l0 =  =
_LO_EvalSymbol : =
_LO_Eval : l1 =  =
LO_EvalList : lfunction =  = kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 100
_LO_Eval : l1 =  100
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 100 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  100
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  = ( 100 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 100 <: 0x00007ffff77cba40 :> d: (count-change 100)
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 100 <: 1 cell pushed. TOS changed to 0x0000000000000064.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77becd8 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Lisp :> = <: cprimitive :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> = <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  = ( 100 0 ) 0
LO_EvalList : lfunction =  = ( 100 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  ( = kinds-of-coins 0 )
_LO_EvalList : le : = 0 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  or ( 0 0 )
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :>  <: 1 cell popped. TOS set to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> or <: cprimitive :>  .. -of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> or <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  or ( 0 0 ) 0
LO_EvalList : lfunction =  or ( 0 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
LO_Cond : testTorF =  0
LO_Cond : conditional =  ( else ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) ) )
LO_Cond : testNode =  else
_LO_Eval : l0 =  else
_LO_EvalSymbol : else
_LO_Eval : l1 =  else
LO_Cond : testTorF =  else
LO_Cond : resultNode =  ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) )
_LO_Eval : l0 =  ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) )
_LO_Eval : l0 =  +
_LO_EvalSymbol : +
_LO_Eval : l1 =  +
LO_EvalList : lfunction =  + ( cc amount ( - kinds-of-coins 1 ) )
_LO_Eval : l0 =  ( cc amount ( - kinds-of-coins 1 ) )
_LO_Eval : l0 =  cc
_LO_EvalSymbol : cc
_LO_Eval : l1 =  cc
LO_EvalList : lfunction =  cc amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 5
_LO_Eval : l1 =  5
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 5 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  5
_LO_Eval : l0 =  ( - kinds-of-coins 1 )
_LO_Eval : l0 =  -
_LO_EvalSymbol : -
_LO_Eval : l1 =  -
LO_EvalList : lfunction =  - kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 100
_LO_Eval : l1 =  100
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 100 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  100
_LO_Eval : l0 =  1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  1
_LO_EvalList : le : = 1 le->Name = 1
_LO_EvalList : LO_CopyOne : le1 :  1
LO_Apply : lfunction with args ::  - ( 100 1 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 100 <: 0x00007ffff77cba40 :> d: (count-change 100)
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 100 <: 1 cell pushed. TOS changed to 0x0000000000000064.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 1 <: 0x00007ffff77c0178 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 1 <: 1 cell pushed. TOS changed to 0x0000000000000001.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Int :> - <: cprimitive :>  (+ (cc amount (- kinds-of-coins 1)) (cc (- amount (first-denomination kinds-of-coins)) kinds-of-coins
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> - <: 1 cell popped. TOS changed to 0x0000000000000063.
LO_Apply : lfunction with args and result ::  - ( 100 1 ) 99
LO_EvalList : lfunction =  - ( 100 1 ) : result l0 =  99
_LO_EvalList : l0 =  99
_LO_Eval : l1 =  99
_LO_EvalList : lnode : =  ( - kinds-of-coins 1 )
_LO_EvalList : le : = 99 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  99
LO_Apply : lfunction with args ::  cc ( 5 99 )
LO_Substitute : lambdaParameters =  ( kinds-of-coins amount )
LO_Substitute : funcCallValues =  ( 5 99 )
LO_Substitute : lambdaParameters =  kinds-of-coins
LO_Substitute : funcCallValues =  5
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  99
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  99
LO_EvalList : special function =  ( cond ( ( <= amount 0 ) 1 ) ( ( or ( < amount 0 ) ( = kinds-of-coins 0 ) ) 0 ) ( else ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) ) ) )
LO_Cond : l0 =  cond
LO_Cond : conditional =  ( ( <= amount 0 ) 1 )
LO_Cond : testNode =  ( <= amount 0 )
_LO_Eval : l0 =  ( <= amount 0 )
_LO_Eval : l0 =  <=
_LO_EvalSymbol : <=
_LO_Eval : l1 =  <=
LO_EvalList : lfunction =  <= amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 99
_LO_Eval : l1 =  99
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 99 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  99
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  <= ( 99 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> amount <: 0x00007ffff74b12c0 :>  .. cc amount kinds-of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> amount <: 1 cell pushed. TOS changed to 0x0000000000000063.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77bd838 :> d: (count-change 100)
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> <= <: cprimitive :>  .. e (cc amount kinds-of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coi .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> <= <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  <= ( 99 0 ) 0
LO_EvalList : lfunction =  <= ( 99 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
LO_Cond : testTorF =  0
LO_Cond : conditional =  ( ( or ( < amount 0 ) ( = kinds-of-coins 0 ) ) 0 )
LO_Cond : testNode =  ( or ( < amount 0 ) ( = kinds-of-coins 0 ) )
_LO_Eval : l0 =  ( or ( < amount 0 ) ( = kinds-of-coins 0 ) )
_LO_Eval : l0 =  or
_LO_EvalSymbol : or
_LO_Eval : l1 =  or
LO_EvalList : lfunction =  or ( < amount 0 )
_LO_Eval : l0 =  ( < amount 0 )
_LO_Eval : l0 =  <
_LO_EvalSymbol : <
_LO_Eval : l1 =  <
LO_EvalList : lfunction =  < amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 99
_LO_Eval : l1 =  99
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 99 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  99
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  < ( 99 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> amount <: 0x00007ffff74b1bc8 :>  .. ins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0 .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> amount <: 1 cell pushed. TOS changed to 0x0000000000000063.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77be5f8 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> < <: cprimitive :>  .. coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ (cc  .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> < <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  < ( 99 0 ) 0
LO_EvalList : lfunction =  < ( 99 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  ( < amount 0 )
_LO_EvalList : le : = 0 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  0
_LO_Eval : l0 =  ( = kinds-of-coins 0 )
_LO_Eval : l0 =  =
_LO_EvalSymbol : =
_LO_Eval : l1 =  =
LO_EvalList : lfunction =  = kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 5
_LO_Eval : l1 =  5
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 5 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  5
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  = ( 5 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 5 <: 0x00007ffff77bb3b0 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 5 <: 1 cell pushed. TOS set to 0x0000000000000005.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77becd8 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Lisp :> = <: cprimitive :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> = <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  = ( 5 0 ) 0
LO_EvalList : lfunction =  = ( 5 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  ( = kinds-of-coins 0 )
_LO_EvalList : le : = 0 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  or ( 0 0 )
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :>  <: 1 cell popped. TOS set to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> or <: cprimitive :>  .. -of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> or <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  or ( 0 0 ) 0
LO_EvalList : lfunction =  or ( 0 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
LO_Cond : testTorF =  0
LO_Cond : conditional =  ( else ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) ) )
LO_Cond : testNode =  else
_LO_Eval : l0 =  else
_LO_EvalSymbol : else
_LO_Eval : l1 =  else
LO_Cond : testTorF =  else
LO_Cond : resultNode =  ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) )
_LO_Eval : l0 =  ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) )
_LO_Eval : l0 =  +
_LO_EvalSymbol : +
_LO_Eval : l1 =  +
LO_EvalList : lfunction =  + ( cc amount ( - kinds-of-coins 1 ) )
_LO_Eval : l0 =  ( cc amount ( - kinds-of-coins 1 ) )
_LO_Eval : l0 =  cc
_LO_EvalSymbol : cc
_LO_Eval : l1 =  cc
LO_EvalList : lfunction =  cc amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 99
_LO_Eval : l1 =  99
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 99 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  99
_LO_Eval : l0 =  ( - kinds-of-coins 1 )
_LO_Eval : l0 =  -
_LO_EvalSymbol : -
_LO_Eval : l1 =  -
LO_EvalList : lfunction =  - kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 5
_LO_Eval : l1 =  5
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 5 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  5
_LO_Eval : l0 =  1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  1
_LO_EvalList : le : = 1 le->Name = 1
_LO_EvalList : LO_CopyOne : le1 :  1
LO_Apply : lfunction with args ::  - ( 5 1 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 5 <: 0x00007ffff77bb3b0 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 5 <: 1 cell pushed. TOS set to 0x0000000000000005.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 1 <: 0x00007ffff77c0178 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 1 <: 1 cell pushed. TOS changed to 0x0000000000000001.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Int :> - <: cprimitive :>  (+ (cc amount (- kinds-of-coins 1)) (cc (- amount (first-denomination kinds-of-coins)) kinds-of-coins
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> - <: 1 cell popped. TOS changed to 0x0000000000000004.
LO_Apply : lfunction with args and result ::  - ( 5 1 ) 4
LO_EvalList : lfunction =  - ( 5 1 ) : result l0 =  4
_LO_EvalList : l0 =  4
_LO_Eval : l1 =  4
_LO_EvalList : lnode : =  ( - kinds-of-coins 1 )
_LO_EvalList : le : = 4 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  4
LO_Apply : lfunction with args ::  cc ( 99 4 )
LO_Substitute : lambdaParameters =  ( kinds-of-coins amount )
LO_Substitute : funcCallValues =  ( 99 4 )
LO_Substitute : lambdaParameters =  kinds-of-coins
LO_Substitute : funcCallValues =  99
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  4
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  4
LO_EvalList : special function =  ( cond ( ( <= amount 0 ) 1 ) ( ( or ( < amount 0 ) ( = kinds-of-coins 0 ) ) 0 ) ( else ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) ) ) )
LO_Cond : l0 =  cond
LO_Cond : conditional =  ( ( <= amount 0 ) 1 )
LO_Cond : testNode =  ( <= amount 0 )
_LO_Eval : l0 =  ( <= amount 0 )
_LO_Eval : l0 =  <=
_LO_EvalSymbol : <=
_LO_Eval : l1 =  <=
LO_EvalList : lfunction =  <= amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 4
_LO_Eval : l1 =  4
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 4 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  4
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  <= ( 4 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> amount <: 0x00007ffff74b3f40 :>  .. cc amount kinds-of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> amount <: 1 cell pushed. TOS changed to 0x0000000000000004.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77bd838 :> d: (count-change 100)
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> <= <: cprimitive :>  .. e (cc amount kinds-of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coi .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> <= <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  <= ( 4 0 ) 0
LO_EvalList : lfunction =  <= ( 4 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
LO_Cond : testTorF =  0
LO_Cond : conditional =  ( ( or ( < amount 0 ) ( = kinds-of-coins 0 ) ) 0 )
LO_Cond : testNode =  ( or ( < amount 0 ) ( = kinds-of-coins 0 ) )
_LO_Eval : l0 =  ( or ( < amount 0 ) ( = kinds-of-coins 0 ) )
_LO_Eval : l0 =  or
_LO_EvalSymbol : or
_LO_Eval : l1 =  or
LO_EvalList : lfunction =  or ( < amount 0 )
_LO_Eval : l0 =  ( < amount 0 )
_LO_Eval : l0 =  <
_LO_EvalSymbol : <
_LO_Eval : l1 =  <
LO_EvalList : lfunction =  < amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 4
_LO_Eval : l1 =  4
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 4 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  4
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  < ( 4 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> amount <: 0x00007ffff74b4848 :>  .. ins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0 .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> amount <: 1 cell pushed. TOS changed to 0x0000000000000004.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77be5f8 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> < <: cprimitive :>  .. coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ (cc  .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> < <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  < ( 4 0 ) 0
LO_EvalList : lfunction =  < ( 4 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  ( < amount 0 )
_LO_EvalList : le : = 0 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  0
_LO_Eval : l0 =  ( = kinds-of-coins 0 )
_LO_Eval : l0 =  =
_LO_EvalSymbol : =
_LO_Eval : l1 =  =
LO_EvalList : lfunction =  = kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 99
_LO_Eval : l1 =  99
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 99 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  99
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  = ( 99 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> kinds-of-coins <: 0x00007ffff74b5118 :> d  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ (c
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> kinds-of-coins <: 1 cell pushed. TOS changed to 0x0000000000000063.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77becd8 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Lisp :> = <: cprimitive :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> = <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  = ( 99 0 ) 0
LO_EvalList : lfunction =  = ( 99 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  ( = kinds-of-coins 0 )
_LO_EvalList : le : = 0 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  or ( 0 0 )
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :>  <: 1 cell popped. TOS set to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> or <: cprimitive :>  .. -of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> or <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  or ( 0 0 ) 0
LO_EvalList : lfunction =  or ( 0 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
LO_Cond : testTorF =  0
LO_Cond : conditional =  ( else ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) ) )
LO_Cond : testNode =  else
_LO_Eval : l0 =  else
_LO_EvalSymbol : else
_LO_Eval : l1 =  else
LO_Cond : testTorF =  else
LO_Cond : resultNode =  ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) )
_LO_Eval : l0 =  ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) )
_LO_Eval : l0 =  +
_LO_EvalSymbol : +
_LO_Eval : l1 =  +
LO_EvalList : lfunction =  + ( cc amount ( - kinds-of-coins 1 ) )
_LO_Eval : l0 =  ( cc amount ( - kinds-of-coins 1 ) )
_LO_Eval : l0 =  cc
_LO_EvalSymbol : cc
_LO_Eval : l1 =  cc
LO_EvalList : lfunction =  cc amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 4
_LO_Eval : l1 =  4
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 4 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  4
_LO_Eval : l0 =  ( - kinds-of-coins 1 )
_LO_Eval : l0 =  -
_LO_EvalSymbol : -
_LO_Eval : l1 =  -
LO_EvalList : lfunction =  - kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 99
_LO_Eval : l1 =  99
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 99 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  99
_LO_Eval : l0 =  1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  1
_LO_EvalList : le : = 1 le->Name = 1
_LO_EvalList : LO_CopyOne : le1 :  1
LO_Apply : lfunction with args ::  - ( 99 1 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> kinds-of-coins <: 0x00007ffff74b62f0 :> ds-of-coins 0)) 0) (else (+ (cc amount (- kinds-of-coins 1)) (cc (- amount 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> kinds-of-coins <: 1 cell pushed. TOS changed to 0x0000000000000063.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 1 <: 0x00007ffff77c0178 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 1 <: 1 cell pushed. TOS changed to 0x0000000000000001.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Int :> - <: cprimitive :>  (+ (cc amount (- kinds-of-coins 1)) (cc (- amount (first-denomination kinds-of-coins)) kinds-of-coins
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> - <: 1 cell popped. TOS changed to 0x0000000000000062.
LO_Apply : lfunction with args and result ::  - ( 99 1 ) 98
LO_EvalList : lfunction =  - ( 99 1 ) : result l0 =  98
_LO_EvalList : l0 =  98
_LO_Eval : l1 =  98
_LO_EvalList : lnode : =  ( - kinds-of-coins 1 )
_LO_EvalList : le : = 98 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  98
LO_Apply : lfunction with args ::  cc ( 4 98 )
LO_Substitute : lambdaParameters =  ( kinds-of-coins amount )
LO_Substitute : funcCallValues =  ( 4 98 )
LO_Substitute : lambdaParameters =  kinds-of-coins
LO_Substitute : funcCallValues =  4
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  98
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  98
LO_EvalList : special function =  ( cond ( ( <= amount 0 ) 1 ) ( ( or ( < amount 0 ) ( = kinds-of-coins 0 ) ) 0 ) ( else ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) ) ) )
LO_Cond : l0 =  cond
LO_Cond : conditional =  ( ( <= amount 0 ) 1 )
LO_Cond : testNode =  ( <= amount 0 )
_LO_Eval : l0 =  ( <= amount 0 )
_LO_Eval : l0 =  <=
_LO_EvalSymbol : <=
_LO_Eval : l1 =  <=
LO_EvalList : lfunction =  <= amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 98
_LO_Eval : l1 =  98
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 98 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  98
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  <= ( 98 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> amount <: 0x00007ffff74b6bc0 :>  .. cc amount kinds-of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> amount <: 1 cell pushed. TOS changed to 0x0000000000000062.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77bd838 :> d: (count-change 100)
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> <= <: cprimitive :>  .. e (cc amount kinds-of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coi .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> <= <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  <= ( 98 0 ) 0
LO_EvalList : lfunction =  <= ( 98 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
LO_Cond : testTorF =  0
LO_Cond : conditional =  ( ( or ( < amount 0 ) ( = kinds-of-coins 0 ) ) 0 )
LO_Cond : testNode =  ( or ( < amount 0 ) ( = kinds-of-coins 0 ) )
_LO_Eval : l0 =  ( or ( < amount 0 ) ( = kinds-of-coins 0 ) )
_LO_Eval : l0 =  or
_LO_EvalSymbol : or
_LO_Eval : l1 =  or
LO_EvalList : lfunction =  or ( < amount 0 )
_LO_Eval : l0 =  ( < amount 0 )
_LO_Eval : l0 =  <
_LO_EvalSymbol : <
_LO_Eval : l1 =  <
LO_EvalList : lfunction =  < amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 98
_LO_Eval : l1 =  98
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 98 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  98
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  < ( 98 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> amount <: 0x00007ffff74b74c8 :>  .. ins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0 .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> amount <: 1 cell pushed. TOS changed to 0x0000000000000062.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77be5f8 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> < <: cprimitive :>  .. coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ (cc  .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> < <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  < ( 98 0 ) 0
LO_EvalList : lfunction =  < ( 98 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  ( < amount 0 )
_LO_EvalList : le : = 0 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  0
_LO_Eval : l0 =  ( = kinds-of-coins 0 )
_LO_Eval : l0 =  =
_LO_EvalSymbol : =
_LO_Eval : l1 =  =
LO_EvalList : lfunction =  = kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 4
_LO_Eval : l1 =  4
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 4 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  4
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  = ( 4 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> kinds-of-coins <: 0x00007ffff74b7d98 :> d  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ (c
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> kinds-of-coins <: 1 cell pushed. TOS changed to 0x0000000000000004.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77becd8 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Lisp :> = <: cprimitive :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> = <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  = ( 4 0 ) 0
LO_EvalList : lfunction =  = ( 4 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  ( = kinds-of-coins 0 )
_LO_EvalList : le : = 0 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  or ( 0 0 )
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :>  <: 1 cell popped. TOS set to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> or <: cprimitive :>  .. -of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> or <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  or ( 0 0 ) 0
LO_EvalList : lfunction =  or ( 0 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
LO_Cond : testTorF =  0
LO_Cond : conditional =  ( else ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) ) )
LO_Cond : testNode =  else
_LO_Eval : l0 =  else
_LO_EvalSymbol : else
_LO_Eval : l1 =  else
LO_Cond : testTorF =  else
LO_Cond : resultNode =  ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) )
_LO_Eval : l0 =  ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) )
_LO_Eval : l0 =  +
_LO_EvalSymbol : +
_LO_Eval : l1 =  +
LO_EvalList : lfunction =  + ( cc amount ( - kinds-of-coins 1 ) )
_LO_Eval : l0 =  ( cc amount ( - kinds-of-coins 1 ) )
_LO_Eval : l0 =  cc
_LO_EvalSymbol : cc
_LO_Eval : l1 =  cc
LO_EvalList : lfunction =  cc amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 98
_LO_Eval : l1 =  98
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 98 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  98
_LO_Eval : l0 =  ( - kinds-of-coins 1 )
_LO_Eval : l0 =  -
_LO_EvalSymbol : -
_LO_Eval : l1 =  -
LO_EvalList : lfunction =  - kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 4
_LO_Eval : l1 =  4
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 4 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  4
_LO_Eval : l0 =  1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  1
_LO_EvalList : le : = 1 le->Name = 1
_LO_EvalList : LO_CopyOne : le1 :  1
LO_Apply : lfunction with args ::  - ( 4 1 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> kinds-of-coins <: 0x00007ffff74b8f70 :> ds-of-coins 0)) 0) (else (+ (cc amount (- kinds-of-coins 1)) (cc (- amount 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> kinds-of-coins <: 1 cell pushed. TOS changed to 0x0000000000000004.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 1 <: 0x00007ffff77c0178 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 1 <: 1 cell pushed. TOS changed to 0x0000000000000001.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Int :> - <: cprimitive :>  (+ (cc amount (- kinds-of-coins 1)) (cc (- amount (first-denomination kinds-of-coins)) kinds-of-coins
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> - <: 1 cell popped. TOS changed to 0x0000000000000003.
LO_Apply : lfunction with args and result ::  - ( 4 1 ) 3
LO_EvalList : lfunction =  - ( 4 1 ) : result l0 =  3
_LO_EvalList : l0 =  3
_LO_Eval : l1 =  3
_LO_EvalList : lnode : =  ( - kinds-of-coins 1 )
_LO_EvalList : le : = 3 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  3
LO_Apply : lfunction with args ::  cc ( 98 3 )
LO_Substitute : lambdaParameters =  ( kinds-of-coins amount )
LO_Substitute : funcCallValues =  ( 98 3 )
LO_Substitute : lambdaParameters =  kinds-of-coins
LO_Substitute : funcCallValues =  98
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  3
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  3
LO_EvalList : special function =  ( cond ( ( <= amount 0 ) 1 ) ( ( or ( < amount 0 ) ( = kinds-of-coins 0 ) ) 0 ) ( else ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) ) ) )
LO_Cond : l0 =  cond
LO_Cond : conditional =  ( ( <= amount 0 ) 1 )
LO_Cond : testNode =  ( <= amount 0 )
_LO_Eval : l0 =  ( <= amount 0 )
_LO_Eval : l0 =  <=
_LO_EvalSymbol : <=
_LO_Eval : l1 =  <=
LO_EvalList : lfunction =  <= amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 3
_LO_Eval : l1 =  3
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 3 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  3
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  <= ( 3 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> amount <: 0x00007ffff74b9840 :>  .. cc amount kinds-of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> amount <: 1 cell pushed. TOS changed to 0x0000000000000003.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77bd838 :> d: (count-change 100)
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> <= <: cprimitive :>  .. e (cc amount kinds-of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coi .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> <= <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  <= ( 3 0 ) 0
LO_EvalList : lfunction =  <= ( 3 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
LO_Cond : testTorF =  0
LO_Cond : conditional =  ( ( or ( < amount 0 ) ( = kinds-of-coins 0 ) ) 0 )
LO_Cond : testNode =  ( or ( < amount 0 ) ( = kinds-of-coins 0 ) )
_LO_Eval : l0 =  ( or ( < amount 0 ) ( = kinds-of-coins 0 ) )
_LO_Eval : l0 =  or
_LO_EvalSymbol : or
_LO_Eval : l1 =  or
LO_EvalList : lfunction =  or ( < amount 0 )
_LO_Eval : l0 =  ( < amount 0 )
_LO_Eval : l0 =  <
_LO_EvalSymbol : <
_LO_Eval : l1 =  <
LO_EvalList : lfunction =  < amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 3
_LO_Eval : l1 =  3
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 3 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  3
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  < ( 3 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> amount <: 0x00007ffff74ba148 :>  .. ins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0 .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> amount <: 1 cell pushed. TOS changed to 0x0000000000000003.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77be5f8 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> < <: cprimitive :>  .. coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ (cc  .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> < <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  < ( 3 0 ) 0
LO_EvalList : lfunction =  < ( 3 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  ( < amount 0 )
_LO_EvalList : le : = 0 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  0
_LO_Eval : l0 =  ( = kinds-of-coins 0 )
_LO_Eval : l0 =  =
_LO_EvalSymbol : =
_LO_Eval : l1 =  =
LO_EvalList : lfunction =  = kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 98
_LO_Eval : l1 =  98
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 98 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  98
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  = ( 98 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> kinds-of-coins <: 0x00007ffff74baa18 :> d  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ (c
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> kinds-of-coins <: 1 cell pushed. TOS changed to 0x0000000000000062.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77becd8 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Lisp :> = <: cprimitive :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> = <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  = ( 98 0 ) 0
LO_EvalList : lfunction =  = ( 98 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  ( = kinds-of-coins 0 )
_LO_EvalList : le : = 0 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  or ( 0 0 )
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :>  <: 1 cell popped. TOS set to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> or <: cprimitive :>  .. -of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> or <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  or ( 0 0 ) 0
LO_EvalList : lfunction =  or ( 0 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
LO_Cond : testTorF =  0
LO_Cond : conditional =  ( else ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) ) )
LO_Cond : testNode =  else
_LO_Eval : l0 =  else
_LO_EvalSymbol : else
_LO_Eval : l1 =  else
LO_Cond : testTorF =  else
LO_Cond : resultNode =  ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) )
_LO_Eval : l0 =  ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) )
_LO_Eval : l0 =  +
_LO_EvalSymbol : +
_LO_Eval : l1 =  +
LO_EvalList : lfunction =  + ( cc amount ( - kinds-of-coins 1 ) )
_LO_Eval : l0 =  ( cc amount ( - kinds-of-coins 1 ) )
_LO_Eval : l0 =  cc
_LO_EvalSymbol : cc
_LO_Eval : l1 =  cc
LO_EvalList : lfunction =  cc amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 3
_LO_Eval : l1 =  3
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 3 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  3
_LO_Eval : l0 =  ( - kinds-of-coins 1 )
_LO_Eval : l0 =  -
_LO_EvalSymbol : -
_LO_Eval : l1 =  -
LO_EvalList : lfunction =  - kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 98
_LO_Eval : l1 =  98
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 98 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  98
_LO_Eval : l0 =  1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  1
_LO_EvalList : le : = 1 le->Name = 1
_LO_EvalList : LO_CopyOne : le1 :  1
LO_Apply : lfunction with args ::  - ( 98 1 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> kinds-of-coins <: 0x00007ffff74bbbf0 :> ds-of-coins 0)) 0) (else (+ (cc amount (- kinds-of-coins 1)) (cc (- amount 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> kinds-of-coins <: 1 cell pushed. TOS changed to 0x0000000000000062.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 1 <: 0x00007ffff77c0178 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 1 <: 1 cell pushed. TOS changed to 0x0000000000000001.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Int :> - <: cprimitive :>  (+ (cc amount (- kinds-of-coins 1)) (cc (- amount (first-denomination kinds-of-coins)) kinds-of-coins
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> - <: 1 cell popped. TOS changed to 0x0000000000000061.
LO_Apply : lfunction with args and result ::  - ( 98 1 ) 97
LO_EvalList : lfunction =  - ( 98 1 ) : result l0 =  97
_LO_EvalList : l0 =  97
_LO_Eval : l1 =  97
_LO_EvalList : lnode : =  ( - kinds-of-coins 1 )
_LO_EvalList : le : = 97 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  97
LO_Apply : lfunction with args ::  cc ( 3 97 )
LO_Substitute : lambdaParameters =  ( kinds-of-coins amount )
LO_Substitute : funcCallValues =  ( 3 97 )
LO_Substitute : lambdaParameters =  kinds-of-coins
LO_Substitute : funcCallValues =  3
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  97
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  97
LO_EvalList : special function =  ( cond ( ( <= amount 0 ) 1 ) ( ( or ( < amount 0 ) ( = kinds-of-coins 0 ) ) 0 ) ( else ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) ) ) )
LO_Cond : l0 =  cond
LO_Cond : conditional =  ( ( <= amount 0 ) 1 )
LO_Cond : testNode =  ( <= amount 0 )
_LO_Eval : l0 =  ( <= amount 0 )
_LO_Eval : l0 =  <=
_LO_EvalSymbol : <=
_LO_Eval : l1 =  <=
LO_EvalList : lfunction =  <= amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 97
_LO_Eval : l1 =  97
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 97 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  97
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  <= ( 97 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> amount <: 0x00007ffff74bc4c0 :>  .. cc amount kinds-of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> amount <: 1 cell pushed. TOS changed to 0x0000000000000061.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77bd838 :> d: (count-change 100)
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> <= <: cprimitive :>  .. e (cc amount kinds-of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coi .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> <= <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  <= ( 97 0 ) 0
LO_EvalList : lfunction =  <= ( 97 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
LO_Cond : testTorF =  0
LO_Cond : conditional =  ( ( or ( < amount 0 ) ( = kinds-of-coins 0 ) ) 0 )
LO_Cond : testNode =  ( or ( < amount 0 ) ( = kinds-of-coins 0 ) )
_LO_Eval : l0 =  ( or ( < amount 0 ) ( = kinds-of-coins 0 ) )
_LO_Eval : l0 =  or
_LO_EvalSymbol : or
_LO_Eval : l1 =  or
LO_EvalList : lfunction =  or ( < amount 0 )
_LO_Eval : l0 =  ( < amount 0 )
_LO_Eval : l0 =  <
_LO_EvalSymbol : <
_LO_Eval : l1 =  <
LO_EvalList : lfunction =  < amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 97
_LO_Eval : l1 =  97
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 97 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  97
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  < ( 97 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> amount <: 0x00007ffff74bcdc8 :>  .. ins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0 .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> amount <: 1 cell pushed. TOS changed to 0x0000000000000061.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77be5f8 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> < <: cprimitive :>  .. coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ (cc  .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> < <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  < ( 97 0 ) 0
LO_EvalList : lfunction =  < ( 97 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  ( < amount 0 )
_LO_EvalList : le : = 0 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  0
_LO_Eval : l0 =  ( = kinds-of-coins 0 )
_LO_Eval : l0 =  =
_LO_EvalSymbol : =
_LO_Eval : l1 =  =
LO_EvalList : lfunction =  = kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 3
_LO_Eval : l1 =  3
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 3 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  3
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  = ( 3 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> kinds-of-coins <: 0x00007ffff74bd698 :> d  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ (c
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> kinds-of-coins <: 1 cell pushed. TOS changed to 0x0000000000000003.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77becd8 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Lisp :> = <: cprimitive :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> = <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  = ( 3 0 ) 0
LO_EvalList : lfunction =  = ( 3 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  ( = kinds-of-coins 0 )
_LO_EvalList : le : = 0 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  or ( 0 0 )
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :>  <: 1 cell popped. TOS set to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> or <: cprimitive :>  .. -of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> or <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  or ( 0 0 ) 0
LO_EvalList : lfunction =  or ( 0 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
LO_Cond : testTorF =  0
LO_Cond : conditional =  ( else ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) ) )
LO_Cond : testNode =  else
_LO_Eval : l0 =  else
_LO_EvalSymbol : else
_LO_Eval : l1 =  else
LO_Cond : testTorF =  else
LO_Cond : resultNode =  ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) )
_LO_Eval : l0 =  ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) )
_LO_Eval : l0 =  +
_LO_EvalSymbol : +
_LO_Eval : l1 =  +
LO_EvalList : lfunction =  + ( cc amount ( - kinds-of-coins 1 ) )
_LO_Eval : l0 =  ( cc amount ( - kinds-of-coins 1 ) )
_LO_Eval : l0 =  cc
_LO_EvalSymbol : cc
_LO_Eval : l1 =  cc
LO_EvalList : lfunction =  cc amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 97
_LO_Eval : l1 =  97
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 97 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  97
_LO_Eval : l0 =  ( - kinds-of-coins 1 )
_LO_Eval : l0 =  -
_LO_EvalSymbol : -
_LO_Eval : l1 =  -
LO_EvalList : lfunction =  - kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 3
_LO_Eval : l1 =  3
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 3 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  3
_LO_Eval : l0 =  1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  1
_LO_EvalList : le : = 1 le->Name = 1
_LO_EvalList : LO_CopyOne : le1 :  1
LO_Apply : lfunction with args ::  - ( 3 1 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> kinds-of-coins <: 0x00007ffff74be870 :> ds-of-coins 0)) 0) (else (+ (cc amount (- kinds-of-coins 1)) (cc (- amount 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> kinds-of-coins <: 1 cell pushed. TOS changed to 0x0000000000000003.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 1 <: 0x00007ffff77c0178 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 1 <: 1 cell pushed. TOS changed to 0x0000000000000001.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Int :> - <: cprimitive :>  (+ (cc amount (- kinds-of-coins 1)) (cc (- amount (first-denomination kinds-of-coins)) kinds-of-coins
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> - <: 1 cell popped. TOS changed to 0x0000000000000002.
LO_Apply : lfunction with args and result ::  - ( 3 1 ) 2
LO_EvalList : lfunction =  - ( 3 1 ) : result l0 =  2
_LO_EvalList : l0 =  2
_LO_Eval : l1 =  2
_LO_EvalList : lnode : =  ( - kinds-of-coins 1 )
_LO_EvalList : le : = 2 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  2
LO_Apply : lfunction with args ::  cc ( 97 2 )
LO_Substitute : lambdaParameters =  ( kinds-of-coins amount )
LO_Substitute : funcCallValues =  ( 97 2 )
LO_Substitute : lambdaParameters =  kinds-of-coins
LO_Substitute : funcCallValues =  97
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  2
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  2
LO_EvalList : special function =  ( cond ( ( <= amount 0 ) 1 ) ( ( or ( < amount 0 ) ( = kinds-of-coins 0 ) ) 0 ) ( else ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) ) ) )
LO_Cond : l0 =  cond
LO_Cond : conditional =  ( ( <= amount 0 ) 1 )
LO_Cond : testNode =  ( <= amount 0 )
_LO_Eval : l0 =  ( <= amount 0 )
_LO_Eval : l0 =  <=
_LO_EvalSymbol : <=
_LO_Eval : l1 =  <=
LO_EvalList : lfunction =  <= amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 2
_LO_Eval : l1 =  2
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 2 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  2
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  <= ( 2 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> amount <: 0x00007ffff74bf140 :>  .. cc amount kinds-of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> amount <: 1 cell pushed. TOS changed to 0x0000000000000002.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77bd838 :> d: (count-change 100)
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> <= <: cprimitive :>  .. e (cc amount kinds-of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coi .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> <= <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  <= ( 2 0 ) 0
LO_EvalList : lfunction =  <= ( 2 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
LO_Cond : testTorF =  0
LO_Cond : conditional =  ( ( or ( < amount 0 ) ( = kinds-of-coins 0 ) ) 0 )
LO_Cond : testNode =  ( or ( < amount 0 ) ( = kinds-of-coins 0 ) )
_LO_Eval : l0 =  ( or ( < amount 0 ) ( = kinds-of-coins 0 ) )
_LO_Eval : l0 =  or
_LO_EvalSymbol : or
_LO_Eval : l1 =  or
LO_EvalList : lfunction =  or ( < amount 0 )
_LO_Eval : l0 =  ( < amount 0 )
_LO_Eval : l0 =  <
_LO_EvalSymbol : <
_LO_Eval : l1 =  <
LO_EvalList : lfunction =  < amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 2
_LO_Eval : l1 =  2
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 2 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  2
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  < ( 2 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> amount <: 0x00007ffff74bfa48 :>  .. ins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0 .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> amount <: 1 cell pushed. TOS changed to 0x0000000000000002.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77be5f8 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> < <: cprimitive :>  .. coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ (cc  .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> < <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  < ( 2 0 ) 0
LO_EvalList : lfunction =  < ( 2 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  ( < amount 0 )
_LO_EvalList : le : = 0 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  0
_LO_Eval : l0 =  ( = kinds-of-coins 0 )
_LO_Eval : l0 =  =
_LO_EvalSymbol : =
_LO_Eval : l1 =  =
LO_EvalList : lfunction =  = kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 97
_LO_Eval : l1 =  97
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 97 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  97
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  = ( 97 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> kinds-of-coins <: 0x00007ffff74c0318 :> d  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ (c
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> kinds-of-coins <: 1 cell pushed. TOS changed to 0x0000000000000061.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77becd8 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Lisp :> = <: cprimitive :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> = <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  = ( 97 0 ) 0
LO_EvalList : lfunction =  = ( 97 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  ( = kinds-of-coins 0 )
_LO_EvalList : le : = 0 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  or ( 0 0 )
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :>  <: 1 cell popped. TOS set to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> or <: cprimitive :>  .. -of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> or <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  or ( 0 0 ) 0
LO_EvalList : lfunction =  or ( 0 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
LO_Cond : testTorF =  0
LO_Cond : conditional =  ( else ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) ) )
LO_Cond : testNode =  else
_LO_Eval : l0 =  else
_LO_EvalSymbol : else
_LO_Eval : l1 =  else
LO_Cond : testTorF =  else
LO_Cond : resultNode =  ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) )
_LO_Eval : l0 =  ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) )
_LO_Eval : l0 =  +
_LO_EvalSymbol : +
_LO_Eval : l1 =  +
LO_EvalList : lfunction =  + ( cc amount ( - kinds-of-coins 1 ) )
_LO_Eval : l0 =  ( cc amount ( - kinds-of-coins 1 ) )
_LO_Eval : l0 =  cc
_LO_EvalSymbol : cc
_LO_Eval : l1 =  cc
LO_EvalList : lfunction =  cc amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 2
_LO_Eval : l1 =  2
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 2 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  2
_LO_Eval : l0 =  ( - kinds-of-coins 1 )
_LO_Eval : l0 =  -
_LO_EvalSymbol : -
_LO_Eval : l1 =  -
LO_EvalList : lfunction =  - kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 97
_LO_Eval : l1 =  97
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 97 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  97
_LO_Eval : l0 =  1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  1
_LO_EvalList : le : = 1 le->Name = 1
_LO_EvalList : LO_CopyOne : le1 :  1
LO_Apply : lfunction with args ::  - ( 97 1 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> kinds-of-coins <: 0x00007ffff74c14f0 :> ds-of-coins 0)) 0) (else (+ (cc amount (- kinds-of-coins 1)) (cc (- amount 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> kinds-of-coins <: 1 cell pushed. TOS changed to 0x0000000000000061.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 1 <: 0x00007ffff77c0178 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 1 <: 1 cell pushed. TOS changed to 0x0000000000000001.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Int :> - <: cprimitive :>  (+ (cc amount (- kinds-of-coins 1)) (cc (- amount (first-denomination kinds-of-coins)) kinds-of-coins
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> - <: 1 cell popped. TOS changed to 0x0000000000000060.
LO_Apply : lfunction with args and result ::  - ( 97 1 ) 96
LO_EvalList : lfunction =  - ( 97 1 ) : result l0 =  96
_LO_EvalList : l0 =  96
_LO_Eval : l1 =  96
_LO_EvalList : lnode : =  ( - kinds-of-coins 1 )
_LO_EvalList : le : = 96 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  96
LO_Apply : lfunction with args ::  cc ( 2 96 )
LO_Substitute : lambdaParameters =  ( kinds-of-coins amount )
LO_Substitute : funcCallValues =  ( 2 96 )
LO_Substitute : lambdaParameters =  kinds-of-coins
LO_Substitute : funcCallValues =  2
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  96
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  96
LO_EvalList : special function =  ( cond ( ( <= amount 0 ) 1 ) ( ( or ( < amount 0 ) ( = kinds-of-coins 0 ) ) 0 ) ( else ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) ) ) )
LO_Cond : l0 =  cond
LO_Cond : conditional =  ( ( <= amount 0 ) 1 )
LO_Cond : testNode =  ( <= amount 0 )
_LO_Eval : l0 =  ( <= amount 0 )
_LO_Eval : l0 =  <=
_LO_EvalSymbol : <=
_LO_Eval : l1 =  <=
LO_EvalList : lfunction =  <= amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 96
_LO_Eval : l1 =  96
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 96 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  96
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  <= ( 96 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> amount <: 0x00007ffff74c1dc0 :>  .. cc amount kinds-of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> amount <: 1 cell pushed. TOS changed to 0x0000000000000060.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77bd838 :> d: (count-change 100)
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> <= <: cprimitive :>  .. e (cc amount kinds-of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coi .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> <= <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  <= ( 96 0 ) 0
LO_EvalList : lfunction =  <= ( 96 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
LO_Cond : testTorF =  0
LO_Cond : conditional =  ( ( or ( < amount 0 ) ( = kinds-of-coins 0 ) ) 0 )
LO_Cond : testNode =  ( or ( < amount 0 ) ( = kinds-of-coins 0 ) )
_LO_Eval : l0 =  ( or ( < amount 0 ) ( = kinds-of-coins 0 ) )
_LO_Eval : l0 =  or
_LO_EvalSymbol : or
_LO_Eval : l1 =  or
LO_EvalList : lfunction =  or ( < amount 0 )
_LO_Eval : l0 =  ( < amount 0 )
_LO_Eval : l0 =  <
_LO_EvalSymbol : <
_LO_Eval : l1 =  <
LO_EvalList : lfunction =  < amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 96
_LO_Eval : l1 =  96
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 96 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  96
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  < ( 96 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> amount <: 0x00007ffff74c26c8 :>  .. ins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0 .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> amount <: 1 cell pushed. TOS changed to 0x0000000000000060.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77be5f8 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> < <: cprimitive :>  .. coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ (cc  .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> < <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  < ( 96 0 ) 0
LO_EvalList : lfunction =  < ( 96 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  ( < amount 0 )
_LO_EvalList : le : = 0 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  0
_LO_Eval : l0 =  ( = kinds-of-coins 0 )
_LO_Eval : l0 =  =
_LO_EvalSymbol : =
_LO_Eval : l1 =  =
LO_EvalList : lfunction =  = kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 2
_LO_Eval : l1 =  2
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 2 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  2
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  = ( 2 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> kinds-of-coins <: 0x00007ffff74c2f98 :> d  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ (c
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> kinds-of-coins <: 1 cell pushed. TOS changed to 0x0000000000000002.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77becd8 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Lisp :> = <: cprimitive :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> = <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  = ( 2 0 ) 0
LO_EvalList : lfunction =  = ( 2 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  ( = kinds-of-coins 0 )
_LO_EvalList : le : = 0 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  or ( 0 0 )
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :>  <: 1 cell popped. TOS set to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> or <: cprimitive :>  .. -of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> or <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  or ( 0 0 ) 0
LO_EvalList : lfunction =  or ( 0 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
LO_Cond : testTorF =  0
LO_Cond : conditional =  ( else ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) ) )
LO_Cond : testNode =  else
_LO_Eval : l0 =  else
_LO_EvalSymbol : else
_LO_Eval : l1 =  else
LO_Cond : testTorF =  else
LO_Cond : resultNode =  ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) )
_LO_Eval : l0 =  ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) )
_LO_Eval : l0 =  +
_LO_EvalSymbol : +
_LO_Eval : l1 =  +
LO_EvalList : lfunction =  + ( cc amount ( - kinds-of-coins 1 ) )
_LO_Eval : l0 =  ( cc amount ( - kinds-of-coins 1 ) )
_LO_Eval : l0 =  cc
_LO_EvalSymbol : cc
_LO_Eval : l1 =  cc
LO_EvalList : lfunction =  cc amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 96
_LO_Eval : l1 =  96
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 96 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  96
_LO_Eval : l0 =  ( - kinds-of-coins 1 )
_LO_Eval : l0 =  -
_LO_EvalSymbol : -
_LO_Eval : l1 =  -
LO_EvalList : lfunction =  - kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 2
_LO_Eval : l1 =  2
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 2 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  2
_LO_Eval : l0 =  1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  1
_LO_EvalList : le : = 1 le->Name = 1
_LO_EvalList : LO_CopyOne : le1 :  1
LO_Apply : lfunction with args ::  - ( 2 1 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> kinds-of-coins <: 0x00007ffff74c4170 :> ds-of-coins 0)) 0) (else (+ (cc amount (- kinds-of-coins 1)) (cc (- amount 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> kinds-of-coins <: 1 cell pushed. TOS changed to 0x0000000000000002.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 1 <: 0x00007ffff77c0178 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 1 <: 1 cell pushed. TOS changed to 0x0000000000000001.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Int :> - <: cprimitive :>  (+ (cc amount (- kinds-of-coins 1)) (cc (- amount (first-denomination kinds-of-coins)) kinds-of-coins
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> - <: 1 cell popped. TOS set to 0x0000000000000001.
LO_Apply : lfunction with args and result ::  - ( 2 1 ) 1
LO_EvalList : lfunction =  - ( 2 1 ) : result l0 =  1
_LO_EvalList : l0 =  1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  ( - kinds-of-coins 1 )
_LO_EvalList : le : = 1 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  1
LO_Apply : lfunction with args ::  cc ( 96 1 )
LO_Substitute : lambdaParameters =  ( kinds-of-coins amount )
LO_Substitute : funcCallValues =  ( 96 1 )
LO_Substitute : lambdaParameters =  kinds-of-coins
LO_Substitute : funcCallValues =  96
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  1
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  1
LO_EvalList : special function =  ( cond ( ( <= amount 0 ) 1 ) ( ( or ( < amount 0 ) ( = kinds-of-coins 0 ) ) 0 ) ( else ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) ) ) )
LO_Cond : l0 =  cond
LO_Cond : conditional =  ( ( <= amount 0 ) 1 )
LO_Cond : testNode =  ( <= amount 0 )
_LO_Eval : l0 =  ( <= amount 0 )
_LO_Eval : l0 =  <=
_LO_EvalSymbol : <=
_LO_Eval : l1 =  <=
LO_EvalList : lfunction =  <= amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 1 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  1
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  <= ( 1 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> amount <: 0x00007ffff74c4a40 :>  .. cc amount kinds-of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> amount <: 1 cell pushed. TOS changed to 0x0000000000000001.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77bd838 :> d: (count-change 100)
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> <= <: cprimitive :>  .. e (cc amount kinds-of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coi .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> <= <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  <= ( 1 0 ) 0
LO_EvalList : lfunction =  <= ( 1 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
LO_Cond : testTorF =  0
LO_Cond : conditional =  ( ( or ( < amount 0 ) ( = kinds-of-coins 0 ) ) 0 )
LO_Cond : testNode =  ( or ( < amount 0 ) ( = kinds-of-coins 0 ) )
_LO_Eval : l0 =  ( or ( < amount 0 ) ( = kinds-of-coins 0 ) )
_LO_Eval : l0 =  or
_LO_EvalSymbol : or
_LO_Eval : l1 =  or
LO_EvalList : lfunction =  or ( < amount 0 )
_LO_Eval : l0 =  ( < amount 0 )
_LO_Eval : l0 =  <
_LO_EvalSymbol : <
_LO_Eval : l1 =  <
LO_EvalList : lfunction =  < amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 1 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  1
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  < ( 1 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> amount <: 0x00007ffff74c5348 :>  .. ins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0 .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> amount <: 1 cell pushed. TOS changed to 0x0000000000000001.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77be5f8 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> < <: cprimitive :>  .. coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ (cc  .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> < <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  < ( 1 0 ) 0
LO_EvalList : lfunction =  < ( 1 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  ( < amount 0 )
_LO_EvalList : le : = 0 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  0
_LO_Eval : l0 =  ( = kinds-of-coins 0 )
_LO_Eval : l0 =  =
_LO_EvalSymbol : =
_LO_Eval : l1 =  =
LO_EvalList : lfunction =  = kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 96
_LO_Eval : l1 =  96
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 96 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  96
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  = ( 96 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> kinds-of-coins <: 0x00007ffff74c5c18 :> d  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ (c
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> kinds-of-coins <: 1 cell pushed. TOS changed to 0x0000000000000060.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77becd8 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Lisp :> = <: cprimitive :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> = <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  = ( 96 0 ) 0
LO_EvalList : lfunction =  = ( 96 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  ( = kinds-of-coins 0 )
_LO_EvalList : le : = 0 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  or ( 0 0 )
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :>  <: 1 cell popped. TOS set to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> or <: cprimitive :>  .. -of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> or <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  or ( 0 0 ) 0
LO_EvalList : lfunction =  or ( 0 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
LO_Cond : testTorF =  0
LO_Cond : conditional =  ( else ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) ) )
LO_Cond : testNode =  else
_LO_Eval : l0 =  else
_LO_EvalSymbol : else
_LO_Eval : l1 =  else
LO_Cond : testTorF =  else
LO_Cond : resultNode =  ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) )
_LO_Eval : l0 =  ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) )
_LO_Eval : l0 =  +
_LO_EvalSymbol : +
_LO_Eval : l1 =  +
LO_EvalList : lfunction =  + ( cc amount ( - kinds-of-coins 1 ) )
_LO_Eval : l0 =  ( cc amount ( - kinds-of-coins 1 ) )
_LO_Eval : l0 =  cc
_LO_EvalSymbol : cc
_LO_Eval : l1 =  cc
LO_EvalList : lfunction =  cc amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 1 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  1
_LO_Eval : l0 =  ( - kinds-of-coins 1 )
_LO_Eval : l0 =  -
_LO_EvalSymbol : -
_LO_Eval : l1 =  -
LO_EvalList : lfunction =  - kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 96
_LO_Eval : l1 =  96
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 96 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  96
_LO_Eval : l0 =  1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  1
_LO_EvalList : le : = 1 le->Name = 1
_LO_EvalList : LO_CopyOne : le1 :  1
LO_Apply : lfunction with args ::  - ( 96 1 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> kinds-of-coins <: 0x00007ffff74c6df0 :> ds-of-coins 0)) 0) (else (+ (cc amount (- kinds-of-coins 1)) (cc (- amount 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> kinds-of-coins <: 1 cell pushed. TOS changed to 0x0000000000000060.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 1 <: 0x00007ffff77c0178 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 1 <: 1 cell pushed. TOS changed to 0x0000000000000001.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Int :> - <: cprimitive :>  (+ (cc amount (- kinds-of-coins 1)) (cc (- amount (first-denomination kinds-of-coins)) kinds-of-coins
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> - <: 1 cell popped. TOS changed to 0x000000000000005f.
LO_Apply : lfunction with args and result ::  - ( 96 1 ) 95
LO_EvalList : lfunction =  - ( 96 1 ) : result l0 =  95
_LO_EvalList : l0 =  95
_LO_Eval : l1 =  95
_LO_EvalList : lnode : =  ( - kinds-of-coins 1 )
_LO_EvalList : le : = 95 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  95
LO_Apply : lfunction with args ::  cc ( 1 95 )
LO_Substitute : lambdaParameters =  ( kinds-of-coins amount )
LO_Substitute : funcCallValues =  ( 1 95 )
LO_Substitute : lambdaParameters =  kinds-of-coins
LO_Substitute : funcCallValues =  1
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  95
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  95
LO_EvalList : special function =  ( cond ( ( <= amount 0 ) 1 ) ( ( or ( < amount 0 ) ( = kinds-of-coins 0 ) ) 0 ) ( else ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) ) ) )
LO_Cond : l0 =  cond
LO_Cond : conditional =  ( ( <= amount 0 ) 1 )
LO_Cond : testNode =  ( <= amount 0 )
_LO_Eval : l0 =  ( <= amount 0 )
_LO_Eval : l0 =  <=
_LO_EvalSymbol : <=
_LO_Eval : l1 =  <=
LO_EvalList : lfunction =  <= amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 95
_LO_Eval : l1 =  95
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 95 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  95
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  <= ( 95 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> amount <: 0x00007ffff74c76c0 :>  .. cc amount kinds-of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> amount <: 1 cell pushed. TOS changed to 0x000000000000005f.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77bd838 :> d: (count-change 100)
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> <= <: cprimitive :>  .. e (cc amount kinds-of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coi .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> <= <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  <= ( 95 0 ) 0
LO_EvalList : lfunction =  <= ( 95 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
LO_Cond : testTorF =  0
LO_Cond : conditional =  ( ( or ( < amount 0 ) ( = kinds-of-coins 0 ) ) 0 )
LO_Cond : testNode =  ( or ( < amount 0 ) ( = kinds-of-coins 0 ) )
_LO_Eval : l0 =  ( or ( < amount 0 ) ( = kinds-of-coins 0 ) )
_LO_Eval : l0 =  or
_LO_EvalSymbol : or
_LO_Eval : l1 =  or
LO_EvalList : lfunction =  or ( < amount 0 )
_LO_Eval : l0 =  ( < amount 0 )
_LO_Eval : l0 =  <
_LO_EvalSymbol : <
_LO_Eval : l1 =  <
LO_EvalList : lfunction =  < amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 95
_LO_Eval : l1 =  95
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 95 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  95
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  < ( 95 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> amount <: 0x00007ffff74c7fc8 :>  .. ins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0 .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> amount <: 1 cell pushed. TOS changed to 0x000000000000005f.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77be5f8 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> < <: cprimitive :>  .. coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ (cc  .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> < <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  < ( 95 0 ) 0
LO_EvalList : lfunction =  < ( 95 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  ( < amount 0 )
_LO_EvalList : le : = 0 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  0
_LO_Eval : l0 =  ( = kinds-of-coins 0 )
_LO_Eval : l0 =  =
_LO_EvalSymbol : =
_LO_Eval : l1 =  =
LO_EvalList : lfunction =  = kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 1 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  1
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  = ( 1 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> kinds-of-coins <: 0x00007ffff74c8898 :> d  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ (c
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> kinds-of-coins <: 1 cell pushed. TOS changed to 0x0000000000000001.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77becd8 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Lisp :> = <: cprimitive :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> = <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  = ( 1 0 ) 0
LO_EvalList : lfunction =  = ( 1 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  ( = kinds-of-coins 0 )
_LO_EvalList : le : = 0 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  or ( 0 0 )
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :>  <: 1 cell popped. TOS set to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> or <: cprimitive :>  .. -of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coins 0)) 0) (else (+ .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> or <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  or ( 0 0 ) 0
LO_EvalList : lfunction =  or ( 0 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
LO_Cond : testTorF =  0
LO_Cond : conditional =  ( else ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) ) )
LO_Cond : testNode =  else
_LO_Eval : l0 =  else
_LO_EvalSymbol : else
_LO_Eval : l1 =  else
LO_Cond : testTorF =  else
LO_Cond : resultNode =  ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) )
_LO_Eval : l0 =  ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) )
_LO_Eval : l0 =  +
_LO_EvalSymbol : +
_LO_Eval : l1 =  +
LO_EvalList : lfunction =  + ( cc amount ( - kinds-of-coins 1 ) )
_LO_Eval : l0 =  ( cc amount ( - kinds-of-coins 1 ) )
_LO_Eval : l0 =  cc
_LO_EvalSymbol : cc
_LO_Eval : l1 =  cc
LO_EvalList : lfunction =  cc amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 95
_LO_Eval : l1 =  95
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 95 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  95
_LO_Eval : l0 =  ( - kinds-of-coins 1 )
_LO_Eval : l0 =  -
_LO_EvalSymbol : -
_LO_Eval : l1 =  -
LO_EvalList : lfunction =  - kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 1 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  1
_LO_Eval : l0 =  1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  1
_LO_EvalList : le : = 1 le->Name = 1
_LO_EvalList : LO_CopyOne : le1 :  1
LO_Apply : lfunction with args ::  - ( 1 1 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> kinds-of-coins <: 0x00007ffff74c9a70 :> ds-of-coins 0)) 0) (else (+ (cc amount (- kinds-of-coins 1)) (cc (- amount 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> kinds-of-coins <: 1 cell pushed. TOS changed to 0x0000000000000001.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 1 <: 0x00007ffff77c0178 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 1 <: 1 cell pushed. TOS set to 0x0000000000000001.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Int :> - <: cprimitive :>  (+ (cc amount (- kinds-of-coins 1)) (cc (- amount (first-denomination kinds-of-coins)) kinds-of-coins
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> - <: 1 cell popped. TOS changed to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  - ( 1 1 ) 0
LO_EvalList : lfunction =  - ( 1 1 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  ( - kinds-of-coins 1 )
_LO_EvalList : le : = 0 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  cc ( 95 0 )
LO_Substitute : lambdaParameters =  ( kinds-of-coins amount )
LO_Substitute : funcCallValues =  ( 95 0 )
LO_Substitute : lambdaParameters =  kinds-of-coins
LO_Substitute : funcCallValues =  95
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  0
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  0
LO_EvalList : special function =  ( cond ( ( <= amount 0 ) 1 ) ( ( or ( < amount 0 ) ( = kinds-of-coins 0 ) ) 0 ) ( else ( + ( cc amount ( - kinds-of-coins 1 ) ) ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins ) ) ) )
LO_Cond : l0 =  cond
LO_Cond : conditional =  ( ( <= amount 0 ) 1 )
LO_Cond : testNode =  ( <= amount 0 )
_LO_Eval : l0 =  ( <= amount 0 )
_LO_Eval : l0 =  <=
_LO_EvalSymbol : <=
_LO_Eval : l1 =  <=
LO_EvalList : lfunction =  <= amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 0 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  0
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  <= ( 0 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> amount <: 0x00007ffff74ca340 :>  .. cc amount kinds-of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> amount <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77bd838 :> d: (count-change 100)
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS set to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Logic :> <= <: cprimitive :>  .. e (cc amount kinds-of-coins) (cond  ((<= amount 0) 1) ((or (< amount 0) (= kinds-of-coi .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> <= <: 1 cell popped. TOS changed to 0x0000000000000001.
LO_Apply : lfunction with args and result ::  <= ( 0 0 ) 1
LO_EvalList : lfunction =  <= ( 0 0 ) : result l0 =  1
_LO_EvalList : l0 =  1
_LO_Eval : l1 =  1
LO_Cond : testTorF =  1
LO_Cond : resultNode =  1
_LO_Eval : l0 =  1
_LO_Eval : l1 =  1
LO_Cond : result =  1
_LO_EvalList : l0 =  1
LO_Apply : lfunction with args and result ::  cc ( 95 0 ) 1
LO_EvalList : lfunction =  cc ( 95 0 ) : result l0 =  1
_LO_EvalList : l0 =  1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  ( cc amount ( - kinds-of-coins 1 ) )
_LO_EvalList : le : = 1 le->Name = 1
_LO_EvalList : LO_CopyOne : le1 :  1
_LO_Eval : l0 =  ( cc ( - amount ( first-denomination kinds-of-coins ) ) kinds-of-coins )
_LO_Eval : l0 =  cc
_LO_EvalSymbol : cc
_LO_Eval : l1 =  cc
LO_EvalList : lfunction =  cc ( - amount ( first-denomination kinds-of-coins ) )
_LO_Eval : l0 =  ( - amount ( first-denomination kinds-of-coins ) )
_LO_Eval : l0 =  -
_LO_EvalSymbol : -
_LO_Eval : l1 =  -
LO_EvalList : lfunction =  - amount
_LO_Eval : l0 =  amount
_LO_EvalSymbol : 95
_LO_Eval : l1 =  95
_LO_EvalList : lnode : =  amount
_LO_EvalList : le : = 95 le->Name = amount
_LO_EvalList : LO_CopyOne : le1 :  95
_LO_Eval : l0 =  ( first-denomination kinds-of-coins )
_LO_Eval : l0 =  first-denomination
_LO_EvalSymbol : first-denomination
_LO_Eval : l1 =  first-denomination
LO_EvalList : lfunction =  first-denomination kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 1 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  1
LO_Apply : lfunction with args ::  first-denomination ( 1 )
LO_Substitute : lambdaParameters =  ( kinds-of-coins )
LO_Substitute : funcCallValues =  ( 1 )
LO_Substitute : lambdaParameters =  kinds-of-coins
LO_Substitute : funcCallValues =  1
got 'kinds-of-coins'
LO_EvalList : special function =  ( cond ( ( = kinds-of-coins 0 ) 0 ) ( ( = kinds-of-coins 1 ) 1 ) ( ( = kinds-of-coins 2 ) 5 ) ( ( = kinds-of-coins 3 ) 10 ) ( ( = kinds-of-coins 4 ) 25 ) ( ( = kinds-of-coins 5 ) 50 ) )
LO_Cond : l0 =  cond
LO_Cond : conditional =  ( ( = kinds-of-coins 0 ) 0 )
LO_Cond : testNode =  ( = kinds-of-coins 0 )
_LO_Eval : l0 =  ( = kinds-of-coins 0 )
_LO_Eval : l0 =  =
_LO_EvalSymbol : =
_LO_Eval : l1 =  =
LO_EvalList : lfunction =  = kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 1 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  1
_LO_Eval : l0 =  0
_LO_Eval : l1 =  0
_LO_EvalList : lnode : =  0
_LO_EvalList : le : = 0 le->Name = 0
_LO_EvalList : LO_CopyOne : le1 :  0
LO_Apply : lfunction with args ::  = ( 1 0 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> kinds-of-coins <: 0x00007ffff74cb8c0 :>  .. nomination kinds-of-coins) (cond  ((= kinds-of-coins 0) 0) ((=  .. 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> kinds-of-coins <: 1 cell pushed. TOS changed to 0x0000000000000001.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 0 <: 0x00007ffff77c3730 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 0 <: 1 cell pushed. TOS changed to 0x0000000000000000.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Lisp :> = <: cprimitive :> -coins 3) 10) ((= kinds-of-coins 4) 25) ((= kinds-of-coins 5) 50) ))
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> = <: 1 cell popped. TOS set to 0x0000000000000000.
LO_Apply : lfunction with args and result ::  = ( 1 0 ) 0
LO_EvalList : lfunction =  = ( 1 0 ) : result l0 =  0
_LO_EvalList : l0 =  0
_LO_Eval : l1 =  0
LO_Cond : testTorF =  0
LO_Cond : conditional =  ( ( = kinds-of-coins 1 ) 1 )
LO_Cond : testNode =  ( = kinds-of-coins 1 )
_LO_Eval : l0 =  ( = kinds-of-coins 1 )
_LO_Eval : l0 =  =
_LO_EvalSymbol : =
_LO_Eval : l1 =  =
LO_EvalList : lfunction =  = kinds-of-coins
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 1 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  1
_LO_Eval : l0 =  1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  1
_LO_EvalList : le : = 1 le->Name = 1
_LO_EvalList : LO_CopyOne : le1 :  1
LO_Apply : lfunction with args ::  = ( 1 1 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> kinds-of-coins <: 0x00007ffff74cbfd8 :> oins) (cond  ((= kinds-of-coins 0) 0) ((= kinds-of-coins 1) 1) ((= kinds-of
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> kinds-of-coins <: 1 cell pushed. TOS changed to 0x0000000000000001.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 1 <: 0x00007ffff77c4180 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 1 <: 1 cell pushed. TOS set to 0x0000000000000001.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Lisp :> = <: cprimitive :> -coins 3) 10) ((= kinds-of-coins 4) 25) ((= kinds-of-coins 5) 50) ))
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> = <: 1 cell popped. TOS set to 0x0000000000000001.
LO_Apply : lfunction with args and result ::  = ( 1 1 ) 1
LO_EvalList : lfunction =  = ( 1 1 ) : result l0 =  1
_LO_EvalList : l0 =  1
_LO_Eval : l1 =  1
LO_Cond : testTorF =  1
LO_Cond : resultNode =  1
_LO_Eval : l0 =  1
_LO_Eval : l1 =  1
LO_Cond : result =  1
_LO_EvalList : l0 =  1
LO_Apply : lfunction with args and result ::  first-denomination ( 1 ) 1
LO_EvalList : lfunction =  first-denomination ( 1 ) : result l0 =  1
_LO_EvalList : l0 =  1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  ( first-denomination kinds-of-coins )
_LO_EvalList : le : = 1 le->Name = 1
_LO_EvalList : LO_CopyOne : le1 :  1
LO_Apply : lfunction with args ::  - ( 95 1 )
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> amount <: 0x00007ffff74cae00 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> amount <: 1 cell pushed. TOS changed to 0x000000000000005f.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : <literal> :> 1 <: 0x00007ffff77c4338 :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> 1 <: 1 cell pushed. TOS changed to 0x0000000000000001.
dbg[i]  :: ./namespaces/compiler/lcinit.csl : 62.21 : Int :> - <: cprimitive :> 
Stack : word at ./namespaces/compiler/lcinit.csl : 62.21 :> - <: 1 cell popped. TOS changed to 0x000000000000005e.
LO_Apply : lfunction with args and result ::  - ( 95 1 ) 94
LO_EvalList : lfunction =  - ( 95 1 ) : result l0 =  94
_LO_EvalList : l0 =  94
_LO_Eval : l1 =  94
_LO_EvalList : lnode : =  ( - amount ( first-denomination kinds-of-coins ) )
_LO_EvalList : le : = 94 le->Name = 
_LO_EvalList : LO_CopyOne : le1 :  94
_LO_Eval : l0 =  kinds-of-coins
_LO_EvalSymbol : 1
_LO_Eval : l1 =  1
_LO_EvalList : lnode : =  kinds-of-coins
_LO_EvalList : le : = 1 le->Name = kinds-of-coins
_LO_EvalList : LO_CopyOne : le1 :  1
LO_Apply : lfunction with args ::  cc ( 94 1 )
LO_Substitute : lambdaParameters =  ( kinds-of-coins amount )
LO_Substitute : funcCallValues =  ( 94 1 )
LO_Substitute : lambdaParameters =  kinds-of-coins
LO_Substitute : funcCallValues =  94
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  1
LO_Substitute : lambdaParameters =  amount
LO_Substitute : funcCallValues =  1
